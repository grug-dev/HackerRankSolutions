package com.kkpa.hackerrank;


import java.util.ArrayList;

/**
 * https://www.hackerrank.com/challenges/java-vistor-pattern/problem?isFullScreen=true
 * <p>
 * In this problem you must NOT generate any output on your own. Any such solution will be considered as being against the rules and its author will be disqualified. The output of your solution must be generated by the uneditable code provided for you in the solution template.
 * <p>
 * <p>
 * An important concept in Object-Oriented Programming is the open/closed principle, which means writing code that is open to extension but closed to modification. In other words, new functionality should be added by writing an extension for the existing code rather than modifying it and potentially breaking other code that uses it. This challenge simulates a real-life problem where the open/closed principle can and should be applied.
 */
public class VisitorPattern {

  public static void main(String[] args) {
  }

  enum Color {
    RED, GREEN;
  }

  interface TreeVis {
    void visitNode(TreeNode tree);

    int getResult();

    void visitLeaf(TreeLeaf treeLeaf);

  }

  class TreeNode extends Tree {
    private ArrayList<Tree> children = new ArrayList<>();

    public TreeNode(int value, Color color, int depth) {
      super(value, color, depth);
    }

    public void accept(TreeVis visitor) {
      visitor.visitNode(this);
      for (Tree child : children) {
        child.accept(visitor);
      }
    }

    public void addChild(Tree child) {
      children.add(child);
    }
  }

  class TreeLeaf extends Tree {
    public TreeLeaf(int value, Color color, int depth) {
      super(value, color, depth);
    }

    @Override public void accept(TreeVis visitor) {
      visitor.visitLeaf(this);
    }
  }

  abstract class Tree {

    private Color color;
    private int value;
    private int depth;

    public Tree(int value, Color color, int depth) {
      this.value = value;
      this.color = color;
      this.depth = depth;
    }

    public abstract void accept(TreeVis visitor);

    public Color getColor() {
      return color;
    }

    public void setColor(Color color) {
      this.color = color;
    }

    public int getValue() {
      return value;
    }

    public void setValue(int value) {
      this.value = value;
    }

    public int getDepth() {
      return depth;
    }

    public void setDepth(int depth) {
      this.depth = depth;
    }
  }

  class SumInLeavesVisitor implements TreeVis {
    int result = 0;

    @Override public void visitNode(TreeNode tree) {
    }

    @Override public int getResult() {
      return result;
    }

    @Override public void visitLeaf(TreeLeaf treeLeaf) {
      result += treeLeaf.getValue();
    }
  }

  class ProductOfRedNodesVisitor implements TreeVis {
    final int M = 1000000007;
    long result = 1;

    public int getResult() {
      return (int) result;
    }

    public void visitNode(TreeNode node) {
      if (node.getColor() == Color.RED) {
        result = (result * node.getValue()) % M;
      }
    }

    public void visitLeaf(TreeLeaf leaf) {
      if (leaf.getColor() == Color.RED) {
        result = (result * leaf.getValue()) % M;
      }
    }
  }

  class FancyVisitor implements TreeVis {
    int even = 0;
    int green = 0;

    public int getResult() {
      return Math.abs(even - green);
    }

    public void visitNode(TreeNode node) {
      if (node.getDepth() % 2 == 0) {
        even += node.getValue();
      }
    }

    public void visitLeaf(TreeLeaf leaf) {
      if (leaf.getColor() == Color.GREEN) {
        green += leaf.getValue();
      }
    }
  }
}
